Let code speak
==============

#!/usr/bin/env python
# Author: <Chaobin Tang ctang@redhat.com>
from ws4py.server import geventserver

from frog.core.websockets.base import ApplicationSocket
from frog.contrib.events.handlers.base import BaseJsonEventHandler, \
                                              JsonEventDispatcherApplication

class EchoEventHandler(BaseJsonEventHandler):

    event_type = "echo"

    def proceed(self, data):
        return {'type': 'reply', 'data': data}

class NewConnectionHandler(BaseJsonEventHandler):

    event_type = "_opened"

    def proceed(self, data):
        print "new connection established"
        return {'type': 'reply', 'data': {'msg': 'welcome'}}

This is pretty much what you need to write to write a websocket application that
talks with client using an event-driven approach.


Example
=======

$ PYTHONPATH setup ...
$ export FROG_SETTINGS_MODULE=echo.settings
$ python echo/manage.py serve

Usage
=====
As many utilities are being built into commands, such as create_project or create_handler,
the detailed usage documentation will be written later.

But if you are looking to give a quick try, you can follow the structure of the echo example.


Benchmark
=========

Frog is based on gevent and ws4py (which comes with a dropped-in replacement over gevent's wsgi handler). 
It should have advantages that gevent ships. I did a very simple test with my chrome console,
and my ubuntu virtualized on vmware-fusion with 512mb + 1 core, with opening all kinds of applications
and my DEV environment, the server and client is able to talk 10,000 times in 5 seconds.
This is not that good actually, but there are much to do about it. It will be attention in futurn
versions.

Dependencies
============

Frog depends only what ws4py and gevent depended, plus these two packages themselves of course.